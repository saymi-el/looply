import OpenAI from 'openai';
import { env } from '../../config/env.js';
import logger from '../../config/logger.js';

// Types pour la r√©ponse du script
export interface GeneratedScript {
    text: string;
    duration: number;
    videoPrompts: VideoPrompt[];
}

export interface VideoPrompt {
    positive: string;
    negative: string;
    scene: string;
    timing: {
        start: number;
        end: number;
    };
}

// Initialisation du client OpenAI
const openai = env.OPENAI_API_KEY ? new OpenAI({
    apiKey: env.OPENAI_API_KEY,
}) : null;

export async function generateScript(input: { 
    topic?: string; 
    tone?: string; 
    context?: any;
    duration?: number;
}): Promise<GeneratedScript> {
    const duration = input.duration || 15; // 15 secondes par d√©faut
    const topic = input.topic || 'contenu g√©n√©raliste';
    const tone = input.tone || 'professionnel';

    // Fallback si pas d'API key OpenAI
    if (!openai || !env.OPENAI_API_KEY) {
        logger.warn('OpenAI API key not configured, using fallback script generation');
        return generateFallbackScript(topic, tone, duration);
    }

    try {
        const prompt = buildScriptPrompt(topic, tone, duration);
        
        logger.info({ 
            topic, 
            tone, 
            duration,
            prompt: prompt.substring(0, 200) + '...'
        }, 'üì§ Envoi du prompt √† OpenAI GPT-4o-mini');
        
        const response = await openai.chat.completions.create({
            model: "gpt-4o-mini",
            messages: [{ role: "user", content: prompt }],
            max_tokens: 1000,
            temperature: 0.7,
        });

        const content = response.choices[0]?.message?.content;
        if (!content) {
            throw new Error('No content generated by OpenAI');
        }

        logger.info({ 
            model: "gpt-4o-mini",
            usage: response.usage,
            rawResponse: content
        }, 'üì• R√©ponse brute re√ßue d\'OpenAI');

        const parsed = parseOpenAIResponse(content, duration);
        
        logger.info({ 
            topic, 
            tone, 
            duration, 
            scriptLength: parsed.text.length,
            promptsCount: parsed.videoPrompts.length,
            finalScript: parsed.text,
            finalPrompts: parsed.videoPrompts
        }, '‚úÖ Script pars√© et valid√©');

        return parsed;

    } catch (error) {
        logger.error({ error, topic, tone }, 'Failed to generate script with OpenAI');
        // Fallback en cas d'erreur
        return generateFallbackScript(topic, tone, duration);
    }
}

function buildScriptPrompt(topic: string, tone: string, duration: number): string {
    return `G√©n√®re un script vid√©o de ${duration} secondes sur le sujet "${topic}" avec un ton ${tone}.

Le script doit √™tre structur√© comme suit :
1. Un texte narratif fluide et engageant de ${duration} secondes (environ ${Math.round(duration * 2.5)} mots)
2. 3 prompts vid√©o pour g√©n√©rer les images avec WAN 2.2

Format de r√©ponse attendu (JSON strict) :
{
  "text": "Le script narratif complet...",
  "videoPrompts": [
    {
      "scene": "Description de la sc√®ne",
      "positive": "prompt positif d√©taill√© pour WAN 2.2",
      "negative": "√©l√©ments √† √©viter (low quality, blurry, distorted)",
      "timing": { "start": 0, "end": 5 }
    },
    {
      "scene": "Description de la sc√®ne",
      "positive": "prompt positif d√©taill√© pour WAN 2.2", 
      "negative": "√©l√©ments √† √©viter (low quality, blurry, distorted)",
      "timing": { "start": 5, "end": 10 }
    },
    {
      "scene": "Description de la sc√®ne",
      "positive": "prompt positif d√©taill√© pour WAN 2.2",
      "negative": "√©l√©ments √† √©viter (low quality, blurry, distorted)", 
      "timing": { "start": 10, "end": 15 }
    }
  ]
}

Crit√®res importants :
- Le script doit √™tre naturel et fluide pour la narration
- Les prompts positifs doivent √™tre d√©taill√©s et sp√©cifiques pour WAN 2.2
- Les prompts n√©gatifs doivent inclure les d√©fauts typiques √† √©viter
- Le timing doit couvrir exactement ${duration} secondes
- Utilise un vocabulaire riche et vari√©`;
}

function parseOpenAIResponse(content: string, duration: number): GeneratedScript {
    try {
        logger.info({ originalContent: content }, 'üîç Contenu brut √† parser');
        
        // Nettoyer le contenu en retirant les balises markdown JSON
        const cleanContent = content
            .replace(/```json\n?/g, '')
            .replace(/```\n?/g, '')
            .trim();
            
        logger.info({ cleanedContent: cleanContent }, 'üßπ Contenu nettoy√©');
            
        // Essai de parser le JSON nettoy√©
        const parsed = JSON.parse(cleanContent);
        
        logger.info({ parsedObject: parsed }, 'üìù JSON pars√© avec succ√®s');
        
        if (parsed.text && parsed.videoPrompts && Array.isArray(parsed.videoPrompts)) {
            return {
                text: parsed.text,
                duration: duration,
                videoPrompts: parsed.videoPrompts.map((prompt: any, index: number) => ({
                    scene: prompt.scene || `Sc√®ne ${index + 1}`,
                    positive: prompt.positive || '',
                    negative: prompt.negative || 'low quality, blurry, distorted, ugly, bad anatomy',
                    timing: prompt.timing || {
                        start: Math.floor(index * duration / 3),
                        end: Math.floor((index + 1) * duration / 3)
                    }
                }))
            };
        }
    } catch (error) {
        logger.warn({ error, content }, 'Failed to parse OpenAI JSON response');
    }

    // Fallback si le parsing √©choue
    return {
        text: content.replace(/```json|```/g, '').trim(),
        duration: duration,
        videoPrompts: generateDefaultPrompts(duration)
    };
}

function generateFallbackScript(topic: string, tone: string, duration: number): GeneratedScript {
    const text = `D√©couvrez ${topic} sous un angle ${tone}. Cette approche innovante transforme notre compr√©hension du sujet. Gr√¢ce aux derni√®res avanc√©es, nous pouvons maintenant explorer de nouvelles perspectives fascinantes qui ouvrent des horizons inattendus.`;
    
    return {
        text,
        duration,
        videoPrompts: generateDefaultPrompts(duration, topic)
    };
}

function generateDefaultPrompts(duration: number, topic?: string): VideoPrompt[] {
    const segmentDuration = Math.floor(duration / 3);
    const basePrompt = topic ? `professional ${topic} content` : 'professional content';
    
    return [
        {
            scene: "Introduction",
            positive: `${basePrompt}, clean modern design, high quality, detailed, cinematic lighting`,
            negative: "low quality, blurry, distorted, ugly, bad anatomy, text, watermark",
            timing: { start: 0, end: segmentDuration }
        },
        {
            scene: "D√©veloppement",
            positive: `${basePrompt}, dynamic composition, vibrant colors, sharp focus, professional`,
            negative: "low quality, blurry, distorted, ugly, bad anatomy, text, watermark",
            timing: { start: segmentDuration, end: segmentDuration * 2 }
        },
        {
            scene: "Conclusion",
            positive: `${basePrompt}, inspiring finale, excellent quality, detailed, masterpiece`,
            negative: "low quality, blurry, distorted, ugly, bad anatomy, text, watermark",
            timing: { start: segmentDuration * 2, end: duration }
        }
    ];
}